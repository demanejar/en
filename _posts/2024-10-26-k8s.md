---
title: Understanding K8s Overview
author: longpt 
date: 2025-04-12 20:52:00 +0700
categories: [Blogging]
tags: [k8s]
math: true
mermaid: true
image:
  src: https://longpt233.github.io/images/2024-02-22%2021-44-01.png
---

Some initial research about k8s.

1. Relationship between containerd and docker

- Low level runtime is currently mainly runc
- High level runtime is currently mainly using containerd

```mermaid
graph TD;
    A[Docker CLI]-->|docker run ...|B[Docker Engine];
    B[Docker Daemon];
    B -->C[Containerd];

    C --> D[Open Container Initiative OCI. 2015 by Docker];
    D --> |Implement|E[runc Golang];
    D --> |Implement|CR[crun C];
    D --> |Implement|FC[firecracker-containerd AWS Lambda];

    E --> CO[container]
    CR --> CO[container]
    FC --> CO[container]

    F[Kubernetes] --> G[Container Runtime Interface CRI - K8s API];
    G-->|dockershim. 1.24 k8s remove|B
    G -->|Implement| C[Containerd from Docker];
    G --->|Implement| H[CRI-O from Red Hat - OpenShift, IBM..];
    H --> D

    subgraph Docker
    A
        B
        
    end

    subgraph High Level Runtime: pull image. network. storage
        C
        H
    end

    subgraph Low Level Runtime
        E
        CR
        FC
    end

    subgraph Kubernetes
        F
        G
    end
```

- k8s is removing docker runtime from version 1.24
- removing doesn't mean having to change docker-formatted containers (meaning dockerfile standard is still kept)
- both containerd and CRI-O can run docker-formatted and OCI-formatted images, the difference is they can run without needing to use docker commands from docker daemon


- [detailed review article](https://vineetcic.medium.com/the-differences-between-docker-containerd-cri-o-and-runc-a93ae4c9fdac)


2. Container Component Model

Simply understand containers: group processes together to isolate

History of container formation:

- don't want to waste effort creating another VM to make everything completely independent
- want to manage independent environments more lightly (direct interaction)

![VM vs container](https://raw.githubusercontent.com/demanejar/image-collection/refs/heads/main/k8s/vm_container.png)

Distinguishing virtualization and Container:
- virtualization works with VMs, containers work directly with processes

Docker in the overall picture of containers:

![container](https://raw.githubusercontent.com/demanejar/image-collection/refs/heads/main/k8s/container.png)

Previously, Docker included 3 parts:
- Managing images, network, volume (now it shifts to only managing this part - parallel in function and responsibility with K8S)
- container manager -> shifted to using containerd (CNCF)
- container runtime -> shifted to runc (CNCF)

I have this open question for you: why can't systemd run in containers?

3. Components of k8s

I'll introduce a basic model of K8S

![k8s](https://raw.githubusercontent.com/demanejar/image-collection/refs/heads/main/k8s/k8s.png)

Will include the following basic components:

- Runtime (containerd)
- kubelet: runs on nodes
- Master: etcd (database - stores cluster information), scheduler, api-server, controller
- HA for api-server: can use nginx or haproxy, combined with keepalived
- Kube-proxy

Details about component interactions, network, volume... I'll see you in the distant future :D

